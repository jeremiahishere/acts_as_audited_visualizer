<div class="content">This is the audit history<br /></div>
<script type="text/paperscript" canvas="visualization_canvas">

  var RandomMoverGroup = Base.extend({
    initialize: function(num_paths)  {
      this.num_fill_colors = 6;
      this.fill_colors = new Array("blue", "red", "green", "yellow", "purple", "orange");
      this.movers = [];
      this.num_paths = num_paths
      for(var i = 0; i < this.num_paths; i++)  {
        var color = this.fill_colors[i % this.num_fill_colors]
        this.movers.push(new Mover(color, i));
        if(i > this.num_fill_colors)  {
          start = this.movers[i]
          end = this.find_mover_with_same_color(start, i);
          var conn = new Connection(start, end, color);
        }
      }
    },
    find_mover_with_same_color: function(yourself, max)  {
      while(true)  {
        var potential_match = Math.floor(Math.random() * max)
        match = this.movers[potential_match];
        //check if the randomly generated target matches the color of the current
        if(match != yourself && match.path.style.fillColor == yourself.path.style.fillColor)  {
          return match;
        }
      }
    },
    update_positions: function()  {
      for(var i = 0; i < this.num_paths; i++)  {
        var mover = this.movers[i];
        var vector = mover.move_to_destination();

        if (vector.length < 5) {
          //set the destination
          match = this.find_mover_with_same_color(mover, this.num_paths);
          mover.destination = new Point(match.path.bounds.x,  match.path.bounds.y);
          //hack to move to random point if we go out of bounds
          if(mover.destination.x < 0 || mover.destination.y < 0)  {
            mover.destination = Point.random() * view.size;
          }
          mover.randomize_rotate_speed();
        } else {
          mover.update_rotation();
        }
      }
    },
    handle_mouse_down: function(event)  {
      //this should probably be moved to the initializer
      var hit_options = {
        fill: true,
        tolerance: 5,
      };
      //captures the click event location
      var hit_result = project.hitTest(event.point, hit_options);
      //make sure we are on the inside of a path that has an inside
      if(hit_result)  {
        if(hit_result.type == "fill")  {
          //loop over all the movers, and try to find one that matches the hit result
          for(var i = 0; i < this.num_paths; i++)  {
            if(this.movers[i].path == hit_result.item)  {
              //triple the size
              this.movers[i].set_scale(3);
            }
          }
        }
      }
    },
  });

  var Connection = Base.extend({
    initialize: function(start, end, color)  {
      this.path = new Path();
      this.path.strokeColor = color;
      this.start = start
      this.end = end

      start_point = start.add_connection(this);
      end_point = end.add_connection(this);
      start_half_point = new Point((start_point.x + end_point.x) / 2, start_point.y);
      end_half_point = new Point((start_point.x + end_point.x) / 2, end_point.y);

      this.path.add(start_point);
      this.path.add(start_half_point);
      this.path.add(end_half_point);
      this.path.add(end_point);
    },
    update_position: function(caller, new_pos)  {
      if(caller == this.start)  {
        this.path.segments[0].point.x = new_pos.x;
        this.path.segments[0].point.y = new_pos.y;
        this.path.segments[1].point.y = new_pos.y;
      } else  {
        this.path.segments[3].point.x = new_pos.x;
        this.path.segments[3].point.y = new_pos.y;
        this.path.segments[2].point.y = new_pos.y;
      }
      this.path.segments[1].point.x = (this.path.segments[0].point.x + this.path.segments[3].point.x) / 2;
      this.path.segments[2].point.x = (this.path.segments[0].point.x + this.path.segments[3].point.x) / 2;
      //need to adjust the y coordinates to give a rounded rectangle style coordinates
      //probably need two points per corner
      //this.path.smooth();
    },
  });
  
  var Mover = Base.extend({
    initialize: function(color, num)  {
      //num can possibly be zero, so make sure it has a minimum size
      this.path = new Path.Circle(view.center + num, num+1);
      //this.path = new Path.RegularPolygon(view.center + num, (num % 10) + 3, num + 1);
      this.path.strokeColor = "white";
      this.path.fillColor = color;
      //makes everything slow as shit
      //this.path.opacity = 0.8;

      this.text = new PointText(this.path.position);
      this.text.paragraphStyle.justification = 'center';
      this.text.characterStyle.fontSize = (num+1)/2;
      this.text.fillColor = 'white';
      this.text.content = num;

      this.connections = new Array();

      this.scaling_rate = 0.99 + (Math.random() * 0.01);
      this.destination = Point.random() * view.size;
      //uncomment this line and the bodies of the randomize_rotate_speed and update_rotation methods
      //this.randomize_rotate_speed();
    },
    randomize_rotate_speed: function()  {
      //this.rotate_speed = (Math.random() * 20) - 10;
    },
    update_rotation: function()  {
      //this.path.rotate(this.rotate_speed);
    },
    decrement_scale: function()  {
      this.set_scale(this.scaling_rate);
    },
    increment_scale: function()  {
      this.set_scale(20);
    },
    set_scale: function(amount)  {
      this.path.scale(amount);
      this.text.characterStyle.fontSize *= amount;
    },
    move_to_destination: function()  {
      vector = this.destination - this.path.position;
      this.path.position += vector / 30;
      this.text.position = this.path.position;
      for(var i = 0; i < this.connections.length; i++)  {
        this.connections[i].update_position(this, this.path.position);
      }

      //scaling
      //get the distance squared between the first two segments
      first_segment = this.path.firstSegment;
      second_segment = first_segment.next;
      segment_distance_sq = first_segment.point.getDistance(second_segment.point, true)
      //threshold is roughly 8 px
      if(segment_distance_sq < 65)  {
        //if below the threshold, make it much bigger
        this.increment_scale();
      } else {
        //if above a threshold, make it slightly smaller
        this.decrement_scale();
      }

      return vector;
    },
    add_connection: function(path)  {
      this.connections.push(path);
      return this.path.position;
    },
  });

  var background = new Path.Rectangle(view.bounds);
  background.fillColor = 'black';
  mover_group = new RandomMoverGroup(40);

  function onFrame(event) {
    mover_group.update_positions();
  }

  function onMouseDown(event)  {
    mover_group.handle_mouse_down(event);
  }
</script>
<canvas id="visualization_canvas" resize>
</canvas>

<script>
$(document).ready(function()  {
  var last_update_timestamp = 0;

  //update the canvas with an ajax call to the controller
  function update_audits()  {
    timestamp = self.last_update_timestamp
    $.ajax({
      url: "/acts_as_audited_visualizer/update_audits/" + timestamp,
      dataType: "json",
      success: function(json)  {
        self.last_update_timestamp = Number(new Date());
        //add the new data to the content div
        inner_html = $('.content').html();
        inner_html += audit_to_s(json);
        $('.content').html(inner_html);
      }
    });
  }

  //convert input from the ajax call into tags
  function audit_to_s(audit) {
    output = "";
    $.each(audit, function(id, audit_group)  {
      output += "<div id='audit_group_" + id + "' class='audit_group'>";
      $.each(audit_group, function(key, value)  {
        output += "<span id='" + value.model + "-" + value.id + "' class='content_audit'>";
        output += value.model + "<br />" + value.name + "<br />";
        output += "</span>";
      });
      output += "</div>";
    });
    return output
  }

  //update the canvas every few seconds
  function start_updating() {
    setInterval(update_audits, 10000);
  }  

  //get initial canvas
  update_audits();
  setTimeout(start_updating, 2000);
});
</script>
