<div class="content">This is the audit history<br /></div>
<script type="text/paperscript" canvas="visualization_canvas">

  var RandomMoverGroup = Base.extend({
    initialize: function(num_paths)  {
      this.num_fill_colors = 6;
      this.fill_colors = new Array("blue", "red", "green", "yellow", "purple", "orange");
      this.movers = [];
      this.num_paths = num_paths
      for(var i = 0; i < this.num_paths; i++)  {
        var color = this.fill_colors[i % this.num_fill_colors]
        this.movers.push(new Mover(color, i));
        if(i > this.num_fill_colors)  {
          start = this.movers[i]
          end = this.find_mover_with_same_color(start, i);
          var conn = new Connection(start, end, color);
        }
      }
    },
    find_mover_with_same_color: function(yourself, max)  {
      while(true)  {
        var potential_match = Math.floor(Math.random() * max)
        match = this.movers[potential_match];
        //check if the randomly generated target matches the color of the current
        if(match != yourself && match.path.style.fillColor == yourself.path.style.fillColor)  {
          return match;
        }
      }
    },
    update_positions: function()  {
      for(var i = 0; i < this.num_paths; i++)  {
        var mover = this.movers[i];
        var vector = mover.move_to_destination();

        if (vector.length < 5) {
          //set the destination
          match = this.find_mover_with_same_color(mover, this.num_paths);
          mover.destination = new Point(match.path.bounds.x,  match.path.bounds.y);
          //hack to move to random point if we go out of bounds
          if(mover.destination.x < 0 || mover.destination.y < 0)  {
            mover.destination = Point.random() * view.size;
          }
          mover.randomize_rotate_speed();
        } else {
          mover.update_rotation();
        }
      }
    },
  });

  var Connection = Base.extend({
    initialize: function(start, end, color)  {
      this.path = new Path();
      this.path.strokeColor = color;
      this.start = start
      this.end = end

      start_point = start.add_connection(this);
      end_point = end.add_connection(this);
      start_half_point = new Point((start_point.x + end_point.x) / 2, start_point.y);
      end_half_point = new Point((start_point.x + end_point.x) / 2, end_point.y);

      this.path.add(start_point);
      this.path.add(start_half_point);
      this.path.add(end_half_point);
      this.path.add(end_point);
    },
    update_position: function(caller, new_pos)  {
      if(caller == this.start)  {
        this.path.segments[0].point.x = new_pos.x;
        this.path.segments[0].point.y = new_pos.y;
        this.path.segments[1].point.y = new_pos.y;
      } else  {
        this.path.segments[3].point.x = new_pos.x;
        this.path.segments[3].point.y = new_pos.y;
        this.path.segments[2].point.y = new_pos.y;
      }
      this.path.segments[1].point.x = (this.path.segments[0].point.x + this.path.segments[3].point.x) / 2;
      this.path.segments[2].point.x = (this.path.segments[0].point.x + this.path.segments[3].point.x) / 2;
      //need to adjust the y coordinates to give a rounded rectangle style coordinates
      //probably need two points per corner
      //this.path.smooth();
    },
  });
  
  var Mover = Base.extend({
    initialize: function(color, num)  {
      //path = new Path.Circle(view.center + i, i);
      this.path = new Path.RegularPolygon(view.center + num, (num % 10) + 3, num);
      this.path.strokeColor = "white";
      this.path.fillColor = color;
      //makes everything slow as shit
      //this.path.opacity = 0.8;

      this.text = new PointText(this.path.position);
      this.text.paragraphStyle.justification = 'center';
      this.text.characterStyle.fontSize = num/2;
      this.text.fillColor = 'white';
      this.text.content = num;

      this.connections = new Array();

      this.destination = Point.random() * view.size;
      this.randomize_rotate_speed();
    },
    randomize_rotate_speed: function()  {
      this.rotate_speed = (Math.random() * 20) - 10;
    },
    update_rotation: function()  {
      this.path.rotate(this.rotate_speed);
    },
    move_to_destination: function()  {
      vector = this.destination - this.path.position;
      this.path.position += vector / 30;
      this.text.position = this.path.position;
      for(var i = 0; i < this.connections.length; i++)  {
        this.connections[i].update_position(this, this.path.position);
      }
      return vector;
    },
    add_connection: function(path)  {
      this.connections.push(path);
      return this.path.position;
    },
  });

  var background = new Path.Rectangle(view.bounds);
  background.fillColor = 'black';
  mover_group = new RandomMoverGroup(40);

  function onFrame(event) {
    mover_group.update_positions();
  }
</script>
<canvas id="visualization_canvas" resize>
</canvas>

<script>
$(document).ready(function()  {
  var last_update_timestamp = 0;

  //update the canvas with an ajax call to the controller
  function update_audits()  {
    timestamp = self.last_update_timestamp
    $.ajax({
      url: "/acts_as_audited_visualizer/update_audits/" + timestamp,
      dataType: "json",
      success: function(json)  {
        self.last_update_timestamp = Number(new Date());
        //add the new data to the content div
        inner_html = $('.content').html();
        inner_html += audit_to_s(json);
        $('.content').html(inner_html);
      }
    });
  }

  //convert input from the ajax call into tags
  function audit_to_s(audit) {
    output = "";
    $.each(audit, function(id, audit_group)  {
      output += "<div id='audit_group_" + id + "' class='audit_group'>";
      $.each(audit_group, function(key, value)  {
        output += "<span id='" + value.model + "-" + value.id + "' class='content_audit'>";
        output += value.model + "<br />" + value.name + "<br />";
        output += "</span>";
      });
      output += "</div>";
    });
    return output
  }

  //update the canvas every few seconds
  function start_updating() {
    setInterval(update_audits, 10000);
  }  

  //get initial canvas
  update_audits();
  setTimeout(start_updating, 2000);
});
</script>
